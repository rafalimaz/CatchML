/*
 * generated by Xtext
 */
package br.ufc.great.catchml.ui.outline;

import org.eclipse.swt.graphics.Image;
import org.eclipse.swt.widgets.Display;
import org.eclipse.xtext.ui.editor.outline.IOutlineNode;
import org.eclipse.xtext.ui.editor.outline.impl.AbstractOutlineNode;
import org.eclipse.xtext.ui.editor.outline.impl.DefaultOutlineTreeProvider;
import org.eclipse.xtext.ui.editor.outline.impl.DocumentRootNode;

import br.ufc.great.catchml.catchML.AbstractElement;
import br.ufc.great.catchml.catchML.Declaration;
import br.ufc.great.catchml.catchML.Domainmodel;
import br.ufc.great.catchml.catchML.ExceptionDeclaration;
import br.ufc.great.catchml.catchML.HandlerDeclaration;
import br.ufc.great.catchml.catchML.LogicExpression;
import br.ufc.great.catchml.catchML.PropertyDeclaration;
import br.ufc.great.catchml.catchML.PropositionDeclaration;
import br.ufc.great.catchml.catchML.PropositionExpressionDeclaration;
import br.ufc.great.catchml.catchML.ScopeDeclaration;
import br.ufc.great.catchml.catchML.SemanticConstraintDeclaration;
import br.ufc.great.catchml.catchML.SituationDeclaration;
import br.ufc.great.catchml.catchML.SystemDeclaration;
import br.ufc.great.catchml.catchML.TransitionConstraintDeclaration;

/**
 * customization of the default outline structure
 * 
 */
public class CatchMLOutlineTreeProvider extends DefaultOutlineTreeProvider {
	private Image groupImage = new Image(Display.getDefault(), this
			.getClass().getResourceAsStream("/icons/var.gif"));
	private VirtualOutlineNode sitParentNode;
	private VirtualOutlineNode sconstParentNode;
	private VirtualOutlineNode tconstParentNode;
	private VirtualOutlineNode exParentNode;
	private VirtualOutlineNode scopeParentNode;
	private VirtualOutlineNode specParentNode;
	
	protected void _createChildren(DocumentRootNode parentNode, Domainmodel root) {
		SystemDeclaration element = null;
		for (AbstractElement el : root.getElements()) {
			if (el instanceof SystemDeclaration) {
				cleanGroupNodes();
				element = (SystemDeclaration) el;
				createNode(parentNode, element);
			}
		}
	}

	private void cleanGroupNodes() {
		sitParentNode = null;
		sconstParentNode = null;
		tconstParentNode = null;
		exParentNode = null;
		scopeParentNode = null;
		specParentNode = null;
	}

	protected void _createChildren(IOutlineNode parentNode,
			SystemDeclaration element) {
		Boolean propRootNode = false;
		
		for (Declaration decl : element.getDeclarations()) {
			if (decl instanceof PropositionExpressionDeclaration) {
				if (!propRootNode) {
					createNode(parentNode, decl);
					propRootNode = true;
				}
			} else if (decl instanceof SituationDeclaration) {
				if (sitParentNode == null) {
					VirtualOutlineNode group = new VirtualOutlineNode(
							parentNode, groupImage, "situations", false);
					createEObjectNode(group, decl);
					sitParentNode = group;
				} else {
					createNode((IOutlineNode)sitParentNode, decl);
				}
			} else if (decl instanceof SemanticConstraintDeclaration) {
				if (sconstParentNode == null) {
					VirtualOutlineNode group = new VirtualOutlineNode(
							parentNode, groupImage, "sconstraints", false);
					createEObjectNode(group, decl);
					sconstParentNode = group;
				} else {
					createNode(sconstParentNode, decl);
				}
			} else if (decl instanceof TransitionConstraintDeclaration) {
				if (tconstParentNode == null) {
					VirtualOutlineNode group = new VirtualOutlineNode(
							parentNode, groupImage, "tconstraints", false);
					createEObjectNode(group, decl);
					tconstParentNode = group;			
				} else {
					createNode(tconstParentNode, decl);
				}
			} else if (decl instanceof ExceptionDeclaration) {
				if (exParentNode == null) {
					VirtualOutlineNode group = new VirtualOutlineNode(
							parentNode, groupImage, "exceptions", false);
					createEObjectNode(group, decl);
					exParentNode = group;	
				} else {
					createNode(exParentNode, decl);
				}
			} else if (decl instanceof ScopeDeclaration) {
				if (scopeParentNode == null) {
					VirtualOutlineNode group = new VirtualOutlineNode(
							parentNode, groupImage, "scopes", false);
					createEObjectNode(group, decl);
					scopeParentNode = group;	
				} else {
					createNode(scopeParentNode, decl);
				}
			} else if (decl instanceof PropertyDeclaration) {
				if (specParentNode == null) {
					VirtualOutlineNode group = new VirtualOutlineNode(
							parentNode, groupImage, "specs", false);
					createEObjectNode(group, decl);
					specParentNode = group;
				} else {
					createNode(specParentNode, decl);
				}
			} else {
				createNode(parentNode, decl);
			}
		}
	}

	protected void _createChildren(IOutlineNode parentNode,
			PropositionExpressionDeclaration element) {
		SystemDeclaration system = (SystemDeclaration) element.eContainer();
		for (Declaration decl : system.getDeclarations()) {
			if (decl instanceof PropositionExpressionDeclaration) {				
				for (PropositionDeclaration prop : ((PropositionExpressionDeclaration) decl).getArgs()){
					createNode(parentNode, prop);
				}
			}
		}
	}
	
	protected boolean _isLeaf(PropositionDeclaration exp) {
		return true;
	}
	
	protected boolean _isLeaf(LogicExpression exp) {
		return true;
	}

	protected boolean _isLeaf(HandlerDeclaration exp) {
		return true;
	}

	protected boolean _isLeaf(ExceptionDeclaration exp) {
		return true;
	}

	protected boolean _isLeaf(SituationDeclaration exp) {
		return true;
	}

	protected boolean _isLeaf(ScopeDeclaration exp) {
		return true;
	}

	protected boolean _isLeaf(PropertyDeclaration exp) {
		return true;
	}

	protected boolean _isLeaf(TransitionConstraintDeclaration exp) {
		return true;
	}

	protected boolean _isLeaf(SemanticConstraintDeclaration exp) {
		return true;
	}

	class VirtualOutlineNode extends AbstractOutlineNode {
		protected VirtualOutlineNode(IOutlineNode parent, Image image,
				Object text, boolean isLeaf) {
			super(parent, image, text, isLeaf);
		}
	}
}
